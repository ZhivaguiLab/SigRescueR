#' Executes Bayesian Inference
#'
#' This script utilized by `SigRescueR()` to execute Bayesian inference using the Stan model
#' provided by the `model` object generated by `SigRescueRModel()`. It supports parallel
#' processing of multiple samples and saves posterior sampling as a `.rda` file based on the
#' specified `output_path` and `filename`.
#'
#' @param model An object that contains Stan model configuration, such as number of warm-ups,
#' iterations, and chains, generated by `SigRescueRModel()`.
#' @param treatment A data frame representing the mutational catalogue for exposed samples.
#' Each column corresponds to a sample and must include a `MutationType` column (first column)
#' specifying the mutation context (e.g. `A[C>A]A`), and all other values must be integers.
#' @param control A data frame representing the mutational catalogue for control samples.
#' Similar to treatment, and must include a `MutationType` column (first column) matching the
#' order of the treatment, and all values must be normalized (e.g. relative frequencies)
#' @param output_path A character string specifying the full path where the output `.rda`
#' file will be saved.
#' @param filename A character string specifying the file name.
#'


## Records start time
start_time <- Sys.time()

## Detect cores for rstan and parallel processing
message("Detected ", parallel::detectCores(), " CPU cores.")
if(parallel::detectCores() >= 80) { ## If greater than 80 cores then just use 80 cores
  message("Setting 80 CPU cores for processing parallel runs...")
  options(mc.cores = 80)
} else { ## If less than 80 cores than use all available cores
  message("Setting ", parallel::detectCores(), " CPU cores for processing parallel runs...")
  options(mc.cores = parallel::detectCores())
}

## Load required packages
message("Loading Required Libraries")
packages <- c("rstan", "magrittr", "dplyr", "data.table", "parallel", "tibble")

for (pkg in packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
  suppressMessages(suppressWarnings(library(pkg, character.only = TRUE)))
}


message("Starting Bayesian Modeling...")

## Get sample names
samples <- names(treatment)[-1] ## Remove first entry because that's MutationType
samplelist <- as.list(samples) ## Convert samples object into list for mclapply

## Parallel processing of multiple samples in samplelist
res <- mclapply(X = samplelist, FUN = function(x) {
  ## Check if treatment and control MutationType column match
  if(all(table(control$MutationType == treatment$MutationType))) {
    ## do nothing
    invisible()
  } else { ## If not, match control MutationType with treatment MutationType order
    control <- control[match(treatment$MutationType, control$MutationType),]
  }

  ## Setting up standata
  s_t <- treatment %>% pull(x) %>% as.numeric() ## Exposure Signature

  ## Computing max k for normalizing constant Z in COM-pois per mutation context. Higher count will have higher K
  k_max <- ceiling(s_t + (6 * sqrt(s_t)) + 10)

  ## In case they didn't normalize the control. Normalizing now.
  control_norm <- control %>% column_to_rownames(var = "MutationType") %>% ## Mutation to
    sweep(x = ., MARGIN = 2, STATS = colSums(.), FUN = "/") %>% ## Normalized control Signature
    as.matrix()

  standata <- list(
    N = length(s_t), ## Number of mutation context
    K = ncol(control_norm), ## How many background samples
    k_max = k_max, ## K max per mutation context
    treatment = s_t, ## Observed count for treated sample
    s_b = control_norm, ## Normalized Control Signature
    total_mut = sum(s_t) ## Total Mutation Count
  )

  message(paste0("Running Bayesian Model: ", x))
  fit <- NULL
  fit <- stan(file = model$spath, ## Path to Stan Model
              data = standata,
              warmup = model$warmup, ## Number of warmup
              iter = model$iter, ## Number of iterations
              chains = model$chains, ## Number of chains
              cores = model$cores, ## Number of cores
              refresh = 0,
              control = list(adapt_delta = 0.95))

  message(paste0("Finished Bayesian Model: ", x))
  return(list(fit = fit, s_t = s_t, s_b = control_norm))
}, mc.cores = 20) ## Number of parallel processing (20 means run 20 samples max)

names(res) <- samples

## Save result
message("Saving Results")
save(res, file = paste0(output_path,filename,".rda"))

## Records end time
end_time <- Sys.time()
## Compute total time elapsed
total_time <- end_time - start_time
message("Finished! Total runtime: ", round(as.numeric(total_time, units = "mins"), 2), " minutes")
