#' Create object that contains Stan model configuration for `SigRescueR()`
#'
#' This function creates an object that preloads the selected Stan model with Stan model
#' configurations. By preloading the Stan model, it does not need to be loaded internally
#' each time Bayesian inference is used.
#'
#' @param model A character string specifying the Stan model to use. Default = COM-Poisson.
#' @param warmup An integer to specify the number of warm-up iterations before sampling
#' begins. Default = 1000.
#' @param iter An integer to specify the total number of iterations. The number of posterior
#' sampling is equal to the total number of iterations - the number of warm-up iterations.
#' Default = 2500. Thus, 1500 posterior sampling.
#' @param chains An integer specifying the number of Markov chains to run. Default = 4.
#'
#' @import rstan
#' @export


SigRescueSetup <- function(model = "COM-Poisson", warmup = 1000, iter = 2500, chains = 4) {
  if(model == "COM-Poisson") {
    ## Model name
    model <- "COM-Poisson"
    ## Preload model
    stan_file <- system.file("stan", "com_poisson.stan", package = "SigRescueR")
    smodel <- stan_model(file=stan_file)

    ## Get path to model
    spath <- stan_file

    ## Store configuration as list
    model_setup <- list(model = model, smodel = smodel, spath = spath,
                        warmup = warmup, iter = iter, chains = chains,
                        cores = chains)

    ## Assign to global environment
    assign("model", model_setup, envir = .GlobalEnv)
  }
}

#' Execute Bayesian inference
#'
#' This function creates temporary `.rds` files and R script used to run Bayesian inference
#' using `model_runner.R`. It prepares model data and launch a R process.
#'
#' @param objects A list of objects from the global environment that are temporary saved  and
#' used for Bayesian inference. The list must include `model`, `treatment`, `control`, `output_path`,
#' and `filename`. `model` is an object that contains Stan model configuration, such as number
#' of warm-ups, iterations, and chains, generated by `SigRescueRModel()`. `treatment` is a data
#' frame representing the mutational catalogue for exposed samples. Each column corresponds to a
#' sample and must include a `MutationType` column (first column) specifying the mutation context
#' (e.g. `A[C>A]A`), and all other values must be integers. `control` is a data frame representing
#' the mutational catalogue for control samples. Similar to treatment, and must include a
#' `MutationType` column (first column) matching the order of the treatment, and all values must be
#' normalized (e.g. relative frequencies). `output_path` is a character string specifying the full
#' path where the output `.rda` file will be saved. `filename` is a character string specifying the
#' file name.
#' @param script_path A character string specifying the R script to run the model. Default = model_runner.R
#'
#' @export

SigRescueRun <- function(objects,
                       script_path = system.file("scripts", "model_runner.R", package = "SigRescueR")) {

  tmp_data_files <- list()

  # Save each object to a temporary RDS
  if (!is.null(objects)) {
    for (obj in objects) {
      if (!exists(obj, envir = parent.frame())) stop("Object not found: ", obj)
      tmp_file <- tempfile(fileext = ".rds")
      saveRDS(get(obj, envir = parent.frame()), tmp_file)
      tmp_data_files[[obj]] <- tmp_file
    }
  }

  # Build wrapper script
  wrapper_code <- c()

  # Load objects at start of script
  for (obj in names(tmp_data_files)) {
    wrapper_code <- c(wrapper_code, paste0(obj, " <- readRDS('", tmp_data_files[[obj]], "')"))
  }

  # Source the main script
  wrapper_code <- c(wrapper_code, paste0("source('",script_path,"')"))

  # Write temporary R script
  tmp_script <- tempfile(fileext = ".R")
  writeLines(wrapper_code, tmp_script)

  # Run script
  system2("Rscript", tmp_script, wait = TRUE)
}

#' Extracts posterior sampling from `SigRescueR()`.
#'
#' This function extract the posterior samples from the Bayesian model and computes the
#' posterior mean for the exposure and background while providing some reconstruction
#' metrics and generates the exposure mutational catalogue.
#'
#' @param res An object returned by `SigRescueR()` containing posterior estimates.
#' @param res Numeric value indicating the probability mass of the credible interval used to
#' summarize the posterior (e.g. 0.025 is 2.5% credible interval). Default = 0.025.
#' @param MutationType A character vector specifying the ordered mutation context.
#'
#' @import rstan
#' @importFrom lsa cosine
#' @import dplyr
#' @import tibble
#' @importFrom magrittr %>%
#' @export


SigRescueAnalyze <- function(res, ci = 0.025) {
  ## Function to compute Poisson deviance
  poisson_deviance <- function(y, y_hat) {
    # handle zeros safely
    terms <- ifelse(y == 0, -y_hat, y * log(y / y_hat) - (y - y_hat))
    return(2 * sum(terms))
  }

  ## Function to compute Jensen Shannon Divergence
  js_divergence <- function(p, q, base = 2) {
    # Normalize counts to probability distributions
    p <- p / sum(p)
    q <- q / sum(q)

    m <- 0.5 * (p + q)

    kl_pm <- sum(ifelse(p == 0, 0, p * log(p / m, base)))
    kl_qm <- sum(ifelse(q == 0, 0, q * log(q / m, base)))

    js <- 0.5 * (kl_pm + kl_qm)
    return(js)
  }

  ## List to store summary results
  samp.res <- list()
  ## List to store cleaned signatures
  samp.cleaned <- list()

  ## Process each sample within file
  for(samp in names(res)) {
    message("Processing ", samp)
    ## Get posterior sampling
    fit <- res[[samp]]
    posterior <- rstan::extract(fit$fit)

    ## Extract background and exposure activity
    all_theta <- as.data.frame(posterior$norm_theta_b) %>% ## background activity
      mutate(norm_theta_t = posterior$norm_theta_t) %>% ## treatment activity
      sweep(x = ., MARGIN = 1, STATS = rowSums(.), FUN = "/") %>% ## Row normalize
      colMeans() ## Compute posterior mean

    ## Extract normalized posterior mean for exposure and background activity
    theta_t <- all_theta[length(all_theta)]
    theta_b <- all_theta[-length(all_theta)]

    ## Extract posterior exposure profile and select lower bound (2.5% credible interval)
    s_t <- apply(posterior$s_t, 2, quantile, probs = ci)
    s_t <- s_t / sum(s_t) ## normalize

    ## Convert relative probability distribution to count
    ## (Profile * activity) * total mutation count
    reconstruct_s_t <- (s_t * theta_t) * sum(fit$s_t)

    ## Do same for background profile
    reconstruct_s_b <- sapply(1:length(theta_b), function(x) {
      (as.numeric(fit$s_b[,x]) * theta_b[x]) * sum(fit$s_t)
    })

    ## If more than 1 background supplied, rowSum to get total mutation by mutation context
    if(length(reconstruct_s_b)>1) {
      reconstruct_s_b <- rowSums(reconstruct_s_b)
    }

    ## Sum count for exposure and background to get reconstructed
    reconstructed <- reconstruct_s_t + reconstruct_s_b

    ## If more than 1 background supplied, sum background activity
    if(length(theta_b) > 1) {
      theta_b <- sum(theta_b)
    }

    ## Reconstruction Evaluation ##
    p.dev_recon <- poisson_deviance(fit$s_t, reconstructed)/length(fit$s_t) ## Poisson Deviance
    js_recon <- js_divergence(fit$s_t/sum(fit$s_t), reconstructed/sum(reconstructed)) ## Jensen Shannon Divergence
    cs_recon <- lsa::cosine(fit$s_t, reconstructed)[[1]] ## Cosine Similarity

    ## Store summary in samp.res
    samp.res[[samp]] <- data.frame(sample = samp,
                                   original = sum(fit$s_t),
                                   reconstructed = sum(reconstructed),
                                   poisson_dev = p.dev_recon,
                                   js_recon = js_recon,
                                   cs_recon = cs_recon,
                                   theta_t = theta_t,
                                   theta_b = theta_b)

    ## Store cleaned profiles in samp.cleaned
    samp.cleaned[[samp]] <- data.frame(cleaned = reconstruct_s_t) %>% 'colnames<-' (samp)
  }
  ## Convert list to data frame
  samp.res <- as.data.frame(do.call(rbind, samp.res)) %>% remove_rownames()
  samp.cleaned <- as.data.frame(do.call(cbind, samp.cleaned)) %>%
    'rownames<-' (fit$MutationType) %>%
    rownames_to_column(var = "MutationType")

  ## Generate weighted profile
  ## Generate weighted profile for uncleaned
  mat.mutcat <- as.matrix(samp.cleaned[,-1]) ## Convert df to matrix
  df.sum <- colSums(samp.cleaned[,-1]) ## Get tot mut by sample
  tot.mut <- sum(df.sum) ## Get total mutation across samples
  mat.weight <- as.matrix(df.sum / tot.mut) ## Get weights
  weighted.cleaned <- as.data.frame(mat.mutcat %*% mat.weight) %>% ## matrix multiplication, order matters
    'colnames<-' ("weighted_profile") %>%
    'rownames<-' (samp.cleaned$MutationType) %>%
    rownames_to_column(var = "MutationType")

  ## Assign them to global environment
  assign("samp.cleaned", samp.cleaned, envir = .GlobalEnv)
  assign("samp.cleaned.weighted", weighted.cleaned, envir = .GlobalEnv)
  assign("samp.res", samp.res, envir = .GlobalEnv)
}

#' Plot SBS results.
#'
#' This function is designed to generate a visualization of the results from `SigRescueR()`.
#' SBS-96 mutational signature plots for the original (top left), reconstructed (bottom left),
#' background (top right) and inferred exposure (bottom right). Alpha transparency is set to
#' reflect background (0.5) and exposure (1). The total number of mutations is indicated within
#' the plots. A table with Reconstruction Accuracy (measured by cosine similarity), along with
#' the background and exposure activity.
#'
#' @param res An object returned by `SigRescueR()` containing posterior estimates.
#' @param context Character string specifying the mutation context ("96" or "288").
#' @param ci Numeric value indicating the probability mass of the credible interval used to
#' summarize the posterior (e.g. 0.025 is 2.5% credible interval). Default = 0.025.
#' @param output_path Character string specifying the full path where the ouput `.pdf` file
#' will be saved. Default = current working directory.
#' @param filename Character string specifying the file name. Default = "clean_res".
#' @param dpi Numeric value indicating the resolution (dots per inch) for the saved plot.
#' Default = 600.
#'
#' @import ggplot2
#' @import dplyr
#' @import tibble
#' @importFrom tidyr separate
#' @import ggh4x
#' @import patchwork
#' @import png
#' @import grid
#' @import gt
#' @importFrom magrittr %>%
#' @export

SigRescuePlot <- function(res, context, ci = 0.025, output_path = getwd(), filename = "clean_res", dpi = 600) {
  ## Create temporary storage for plots
  folder <- file.path(getwd(), "png_temp_storage")
  if (!dir.exists(folder)) {
    dir.create(folder)
  }
  ## Functions
  getSBSorder <- function() {
    counter <- 1
    df <- as.data.frame(matrix(data = NA, nrow = 96, ncol = 3))
    all_bp <- c("A", "C", "G", "T")
    pyr_muts <- c("C>A", "C>G", "C>T", "T>A", "T>C", "T>G")
    for(m in pyr_muts){
      for(a in all_bp){
        for(b in all_bp){
          df[counter,1] <- paste(a, "[",m, "]", b, sep="")
          df[counter,2] <- m
          df[counter,3] <- paste(a, substring(m,1,1),b, sep="")
          counter <- counter + 1 ## Add counter for next row
        }
      }
    }
    return(df)
  }

  sbs.df <- getSBSorder()

  if(context == "96") { ## Required functions to plot sbs96
    ## Set pdf height for saving
    pdf.height <- 3.5
    ## Mutation context colors
    mut.color <- c('deepskyblue','black','red','lightgrey','yellowgreen','pink')

    ## Function to plot SBS96
    plotSig <- function(df, x.label, alpha = 1) {
      df.pd <- df %>% left_join(x = ., y = sbs.df, by = c("MutationType"="V1"))
      df.pd$MutationType <- factor(x = df.pd$MutationType, levels = sbs.df$V1)

      anno <- df.pd %>% dplyr::filter(V2 == "T>G") %>%
        mutate(x = Inf,
               y = Inf,
               label = paste0("Total: ", round(sum(df.pd$value), digits = 0))
        )

      p1 <- ggplot(data = df.pd, aes(x = MutationType, y = value/sum(value)*100)) +
        geom_col(aes(fill = V2), alpha = alpha) +
        theme_bw() +
        guides(fill = "none") +
        scale_fill_manual(values = mut.color) +
        facet_wrap2(.~V2, nrow = 1, scale = "free_x", drop = TRUE,
                    strip = strip_themed(
                      background_x = list(
                        element_rect(fill = mut.color[1], color = "transparent"),
                        element_rect(fill = mut.color[2], color = "transparent"),
                        element_rect(fill = mut.color[3], color = "transparent"),
                        element_rect(fill = mut.color[4], color = "transparent"),
                        element_rect(fill = mut.color[5], color = "transparent"),
                        element_rect(fill = mut.color[6], color = "transparent")
                      ),
                      text_x = list(
                        element_text(color = "white", face = "bold", size = 6, margin = margin(1, 1, 1, 1))
                      )
                    )
        ) +
        geom_text(
          data = anno,
          aes(x = x, y = y, label = label),
          inherit.aes = FALSE,
          size = 2.4,
          vjust = 1.1,
          hjust = 1.1
        ) +
        scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
        scale_x_discrete(labels = setNames(sbs.df$V3, sbs.df$V1)) +
        coord_cartesian(clip = "off") +
        ylab("% SBS") + xlab(x.label) +
        theme(panel.border = element_blank(),
              strip.background = element_blank(),
              panel.spacing = unit(0, "lines"),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 3),
              axis.ticks.x = element_blank(),
              axis.text.y = element_text(size = 6),
              axis.title.y = element_text(size = 8),
              axis.title.x = element_text(size = 8))

      return(p1)
    } ## End of required functions to plot sbs96

    ## Function to plot SBS96 with alphas
    plotSig.multialpha <- function(df, x.label, alpha = 1) {
      df.pd <- df %>% left_join(x = ., y = sbs.df, by = c("MutationType"="V1"))
      df.pd$MutationType <- factor(x = df.pd$MutationType, levels = sbs.df$V1)

      anno <- df.pd %>% dplyr::filter(V2 == "T>G") %>%
        mutate(x = Inf,
               y = Inf,
               label = paste0("Total: ", round(sum(df.pd$value), digits = 0))
        )

      p1 <- ggplot(data = df.pd, aes(x = MutationType, y = value/sum(value)*100)) +
        geom_col(aes(fill = V2, alpha = status)) +
        theme_bw() +
        guides(fill = "none") +
        scale_fill_manual(values = mut.color) +
        scale_alpha_manual(values = alpha) +
        facet_wrap2(.~V2, nrow = 1, scale = "free_x", drop = TRUE,
                    strip = strip_themed(
                      background_x = list(
                        element_rect(fill = mut.color[1], color = "transparent"),
                        element_rect(fill = mut.color[2], color = "transparent"),
                        element_rect(fill = mut.color[3], color = "transparent"),
                        element_rect(fill = mut.color[4], color = "transparent"),
                        element_rect(fill = mut.color[5], color = "transparent"),
                        element_rect(fill = mut.color[6], color = "transparent")
                      ),
                      text_x = list(
                        element_text(color = "white", face = "bold", size = 6, margin = margin(1, 1, 1, 1))
                      )
                    )
        ) +
        geom_text(
          data = anno,
          aes(x = x, y = y, label = label),
          inherit.aes = FALSE,
          size = 2.4,
          vjust = 1.1,
          hjust = 1.1
        ) +
        scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
        scale_x_discrete(labels = setNames(sbs.df$V3, sbs.df$V1)) +
        coord_cartesian(clip = "off") +
        ylab("% SBS") + xlab(x.label) +
        theme(panel.border = element_blank(),
              strip.background = element_blank(),
              panel.spacing = unit(0, "lines"),
              legend.position = "none",
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 3),
              axis.ticks.x = element_blank(),
              axis.text.y = element_text(size = 6),
              axis.title.y = element_text(size = 8),
              axis.title.x = element_text(size = 8))

      return(p1)
    }
  } else if(context == "288") { ## Required functions to plot sbs288
    ## Set pdf height for saving
    pdf.height <- 3.5
    ## Mutation context colors
    mut.color <- c('deepskyblue','black','red','lightgrey','yellowgreen','pink')

    ## Function to plot SBS192
    plotSig <- function(df, x.label, alpha = 1) {
      df.pd <- df %>% separate(MutationType, into = c("Strand", "MutationType"), sep = ":", remove = FALSE) %>%
        left_join(x = ., y = sbs.df, by = c("MutationType"="V1"))
      df.pd$MutationType <- factor(x = df.pd$MutationType, levels = sbs.df$V1)

      anno <- df.pd %>% dplyr::filter(V2 == "T>G") %>%
        mutate(x = Inf,
               y = Inf,
               label = paste0("Total: ", round(sum(df.pd$value), digits = 0))
        )

      p1 <- ggplot(df.pd %>% dplyr::filter(Strand != "N"), aes(x = MutationType, y = value/sum(value)*100, group = Strand)) +
        geom_col(aes(fill = Strand), position = position_dodge(width = 0.8)) +
        scale_fill_manual(values = c("firebrick3", "black")) +
        facet_wrap2(.~V2, nrow = 1, scale = "free_x", drop = TRUE,
                    strip = strip_themed(
                      background_x = list(
                        element_rect(fill = mut.color[1], color = "transparent"),
                        element_rect(fill = mut.color[2], color = "transparent"),
                        element_rect(fill = mut.color[3], color = "transparent"),
                        element_rect(fill = mut.color[4], color = "transparent"),
                        element_rect(fill = mut.color[5], color = "transparent"),
                        element_rect(fill = mut.color[6], color = "transparent")
                      ),
                      text_x = list(
                        element_text(color = "white", face = "bold", size = 6, margin = margin(1, 1, 1, 1))
                      )
                    )
        ) +
        theme_bw() +
        geom_text(
          data = anno,
          aes(x = x, y = y, label = label),
          inherit.aes = FALSE, size = 2.4, vjust = 1.1, hjust = 1.1,
          family = "Arial", fontface = "plain"
        ) +
        scale_x_discrete(labels = sbs.df$V3) +
        coord_cartesian(clip = "off") +
        ylab("% SBS") + xlab(x.label) +
        theme(panel.border = element_blank(),
              strip.background = element_blank(),
              panel.spacing = unit(0, "lines"),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 3, margin = margin(t = -1)),
              axis.ticks.x = element_blank(),
              axis.text.y = element_text(size = 6),
              axis.text.y.right = element_text(angle = -90),
              axis.ticks.y.right = element_blank(),
              axis.title.y = element_text(size = 8),
              axis.title.x = element_text(size = 8),
              legend.position = "none")

      return(p1)
    } ## End of required functions to plot sbs192

    plotSig.multialpha <- function(df, x.label, alpha = 1) {
      df.pd <- df %>% separate(MutationType, into = c("Strand", "MutationType"), sep = ":", remove = FALSE) %>%
        left_join(x = ., y = sbs.df, by = c("MutationType"="V1"))
      df.pd$MutationType <- factor(x = df.pd$MutationType, levels = sbs.df$V1)

      anno <- df.pd %>% dplyr::filter(V2 == "T>G") %>%
        mutate(x = Inf,
               y = Inf,
               label = paste0("Total: ", round(sum(df.pd$value), digits = 0))
        )

      p1 <- ggplot(data = df.pd %>% dplyr::filter(Strand != "N"), aes(x = MutationType, y = value/sum(value)*100, group = Strand)) +
        geom_col(aes(fill = Strand, alpha = status), position = position_dodge(width = 0.8)) +
        scale_fill_manual(values = c("firebrick3", "black")) +
        scale_alpha_manual(values = alpha) +
        facet_wrap2(.~V2, nrow = 1, scale = "free_x", drop = TRUE,
                    strip = strip_themed(
                      background_x = list(
                        element_rect(fill = mut.color[1], color = "transparent"),
                        element_rect(fill = mut.color[2], color = "transparent"),
                        element_rect(fill = mut.color[3], color = "transparent"),
                        element_rect(fill = mut.color[4], color = "transparent"),
                        element_rect(fill = mut.color[5], color = "transparent"),
                        element_rect(fill = mut.color[6], color = "transparent")
                      ),
                      text_x = list(
                        element_text(color = "white", face = "bold", size = 6, margin = margin(1, 1, 1, 1))
                      )
                    )
        ) +
        theme_bw() +
        geom_text(
          data = anno,
          aes(x = x, y = y, label = label),
          inherit.aes = FALSE, size = 2.4, vjust = 1.1, hjust = 1.1,
          family = "Arial", fontface = "plain"
        ) +
        scale_x_discrete(labels = sbs.df$V3) +
        coord_cartesian(clip = "off") +
        ylab("% SBS") + xlab(x.label) +
        theme(panel.border = element_blank(),
              strip.background = element_blank(),
              panel.spacing = unit(0, "lines"),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 3, margin = margin(t = -1)),
              axis.ticks.x = element_blank(),
              axis.text.y = element_text(size = 6),
              axis.text.y.right = element_text(angle = -90),
              axis.ticks.y.right = element_blank(),
              axis.title.y = element_text(size = 8),
              axis.title.x = element_text(size = 8),
              legend.position = "none")

      return(p1)
    }

  } ## End of required functions to plot sbs288

  counter2 <- 1
  for(samp in names(res)) {
    ## Get stan fit res for specific samp
    fit <- res[[samp]]
    ## extract posterior draws
    posterior <- rstan::extract(fit$fit)

    ## extract all theta
    all_theta <- as.data.frame(posterior$norm_theta_b) %>% ## background activity
      mutate(norm_theta_t = posterior$norm_theta_t) %>% ## exposure activity
      sweep(x = ., MARGIN = 1, STATS = rowSums(.), FUN = "/") %>% ## normalize
      colMeans()

    ## subset theta based on type (baseline vs treatment)
    theta_t <- all_theta[length(all_theta)]
    theta_b <- all_theta[-length(all_theta)]

    theta_b_ind <- theta_b ## store baseline activity for replicates

    ## extract inferred exposure signautres
    s_t <- apply(posterior$s_t, 2, quantile, probs = ci) ## treatment-induced profile (latent), selected lower bound. less leaky.
    s_t <- s_t / sum(s_t) ## normalize

    ## Reconstruct Exposure
    reconstruct_s_t <- (s_t * theta_t) * sum(fit$s_t)
    ## Reconstruct background
    reconstruct_s_b <- sapply(1:length(theta_b), function(x) {
      (as.numeric(fit$s_b[,x]) * theta_b[x]) * sum(fit$s_t)
    })

    ## Sum all the background together to get one background profile
    if(ncol(reconstruct_s_b)>1) {
      reconstruct_s_b <- rowSums(reconstruct_s_b)
    }

    ## Generate reconstructed profile
    reconstructed <- reconstruct_s_t + reconstruct_s_b

    ##############
    ## Plotting ##
    ## Uncleaned profile (Original)
    original.pd <- data.frame(MutationType = fit$MutationType,
                              value = fit$s_t)
    p1 <- suppressMessages(plotSig(df = original.pd, x.label = "Original"))

    ## Latent st (Cleaned)
    reconstruct_s_t.pd <- data.frame(MutationType = fit$MutationType,
                                     value = as.numeric(reconstruct_s_t))

    p3 <- suppressMessages(plotSig(df = reconstruct_s_t.pd, x.label = "Exposure", alpha = 1))

    ## Fixed sb (Baseline)
    reconstruct_s_b.pd <- data.frame(MutationType = fit$MutationType,
                                     value = as.numeric(reconstruct_s_b))

    p4 <- suppressMessages(plotSig(df = reconstruct_s_b.pd, x.label = "Background", alpha = 0.5))

    ## Reconstructed ( Cleaned + Baseline)
    rsb <- reconstruct_s_b.pd %>% mutate(status = "Background")
    rst <- reconstruct_s_t.pd %>% mutate(status = "Exposure")

    reconstructed.pd <- rbind(rsb, rst)
    reconstructed.pd$status <- factor(x = reconstructed.pd$status, levels = c("Background", "Exposure"))

    p2 <- suppressMessages(plotSig.multialpha(df = reconstructed.pd, x.label = "Reconstructed", alpha = c(0.5, 1)))

    if(context == "288") {
      p2 <- p2 + theme(legend.position = c(0, -0.85),
                       legend.justification = c(0, 0.5),
                       legend.key.size = unit(0.25, "cm"),
                       legend.background = element_rect(fill = NA),
                       legend.key = element_rect(fill = NA),
                       legend.text = element_text(size = 5),
                       legend.title = element_text(size = 5, margin = margin(b = -0.25))) +
        guides(alpha = "none")
    }

    summarytable <- data.frame(
      "Reconstruction Accuracy" = lsa::cosine(as.numeric(reconstructed), as.numeric(fit$s_t)),
      "Background Activity" = sum(theta_b_ind),
      "Exposure Activity" = theta_t,
      check.names = FALSE)

    table.pd <- gt::gt(summarytable) |>
      gt::cols_align(align = "center", columns = everything()) |>
      gt::tab_options(table.font.size = px(10))

    if(context %in% c("96", "288")) {
      ## Plot layout
      layout <- "
      AAAABBBB
      CCCCDDDD
      FFEEEEGG"
    }

    combined_plot1 <- p1 + p4 + p2 + p3 + table.pd + plot_spacer() + plot_layout(design=layout) +
      plot_annotation(title = samp) &
      theme(#plot.tag = element_text(face = 'bold', size = 10),
        plot.title=element_text(hjust=0.5, size = 10),
        text = element_text(family = "Arial"))

    ## Save patchwork plot as png in temp folder
    ggsave(filename = paste0(folder,"/png_", counter2, ".png"), , width = 170, height = 90,
           units = "mm", dpi = 600)
    counter2 <- counter2 + 1
  }

  ## Convert all png files in temp folder into single multi-page PDF
  files <- list.files(path = folder,
                      pattern = "\\.png$", full.names = TRUE)

  pdf(file = paste0(output_path, "/", filename, ".pdf"), height = pdf.height)

  for(f in files) {
    grid::grid.newpage()
    img <- png::readPNG(f)
    grid::grid.raster(img)
  }

  dev.off()

  ## Delete temp folder
  unlink(folder, recursive = TRUE)
}
