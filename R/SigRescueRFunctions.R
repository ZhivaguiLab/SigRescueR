#' Create object that contains Stan model configuration for `SigRescueR()`
#'
#' This function creates an object that preloads the selected Stan model with Stan model
#' configurations. By preloading the Stan model, it does not need to be loaded internally
#' each time Bayesian inference is used.
#'
#' @param model A character string specifying the Stan model to use. Default = COM-Poisson.
#' @param warmup An integer to specify the number of warm-up iterations before sampling
#' begins. Default = 2000.
#' @param iter An integer to specify the total number of iterations. The number of posterior
#' sampling is equal to the total number of iterations - the number of warm-up iterations.
#' Default = 6000. Thus, 4000 posterior sampling.
#' @param chains An integer specifying the number of Markov chains to run. Default = 4.
#'
#' @import rstan
#' @export


SigRescueSetup <- function(model = "COM-Poisson", warmup = 2000, iter = 6000, chains = 4) {
  if(model == "COM-Poisson") {
    ## Model name
    model <- "COM-Poisson"
    ## Preload model
    stan_file <- system.file("stan", "com_poisson.stan", package = "SigRescueR")
    smodel <- stan_model(file=stan_file)

    ## Get path to model
    spath <- stan_file

    ## Store configuration as list
    model_setup <- list(model = model, smodel = smodel, spath = spath,
                        warmup = warmup, iter = iter, chains = chains,
                        cores = chains)

    ## Assign to global environment
    assign("model", model_setup, envir = .GlobalEnv)
  }
}

#' Execute Bayesian inference
#'
#' This function creates temporary `.rds` files and R script used to run Bayesian inference
#' using `model_runner.R`. It prepares model data and launch a R process.
#'
#' @param objects A list of objects from the global environment that are temporary saved  and
#' used for Bayesian inference. The list must include `model`, `treatment`, `control`, `output_path`,
#' and `filename`. `model` is an object that contains Stan model configuration, such as number
#' of warm-ups, iterations, and chains, generated by `SigRescueRModel()`. `treatment` is a data
#' frame representing the mutational catalogue for exposed samples. Each column corresponds to a
#' sample and must include a `MutationType` column (first column) specifying the mutation context
#' (e.g. `A[C>A]A`), and all other values must be integers. `control` is a data frame representing
#' the mutational catalogue for control samples. Similar to treatment, and must include a
#' `MutationType` column (first column) matching the order of the treatment, and all values must be
#' normalized (e.g. relative frequencies). `output_path` is a character string specifying the full
#' path where the output `.rda` file will be saved. `filename` is a character string specifying the
#' file name.
#' @param script_path A character string specifying the R script to run the model. Default = model_runner.R
#'
#' @export

SigRescueRun <- function(objects,
                       script_path = system.file("scripts", "model_runner.R", package = "SigRescueR")) {

  tmp_data_files <- list()

  # Save each object to a temporary RDS
  if (!is.null(objects)) {
    for (obj in objects) {
      if (!exists(obj, envir = parent.frame())) stop("Object not found: ", obj)
      tmp_file <- tempfile(fileext = ".rds")
      saveRDS(get(obj, envir = parent.frame()), tmp_file)
      tmp_data_files[[obj]] <- tmp_file
    }
  }

  # Build wrapper script
  wrapper_code <- c()

  # Load objects at start of script
  for (obj in names(tmp_data_files)) {
    wrapper_code <- c(wrapper_code, paste0(obj, " <- readRDS('", tmp_data_files[[obj]], "')"))
  }

  # Source the main script
  wrapper_code <- c(wrapper_code, paste0("source('",script_path,"')"))

  # Write temporary R script
  tmp_script <- tempfile(fileext = ".R")
  writeLines(wrapper_code, tmp_script)

  # Run script
  system2("Rscript", tmp_script, wait = TRUE)
}

#' Extracts posterior sampling from `SigRescueR()`.
#'
#' This function extract the posterior samples from the Bayesian model and computes the
#' posterior mean for the exposure and background while providing some reconstruction
#' metrics and generates the exposure mutational catalogue.
#'
#' @param res An object returned by `SigRescueR()` containing posterior estimates.
#' @param MutationType A character vector specifying the ordered mutation context.
#'
#' @import rstan
#' @importFrom lsa cosine
#' @import dplyr
#' @import tibble
#' @importFrom magrittr %>%
#' @export


SigRescueAnalyze <- function(res) {
  ## Function to compute Poisson deviance
  poisson_deviance <- function(y, y_hat) {
    # handle zeros safely
    terms <- ifelse(y == 0, -y_hat, y * log(y / y_hat) - (y - y_hat))
    return(2 * sum(terms))
  }

  ## Function to compute Jensen Shannon Divergence
  js_divergence <- function(p, q, base = 2) {
    # Normalize counts to probability distributions
    p <- p / sum(p)
    q <- q / sum(q)

    m <- 0.5 * (p + q)

    kl_pm <- sum(ifelse(p == 0, 0, p * log(p / m, base)))
    kl_qm <- sum(ifelse(q == 0, 0, q * log(q / m, base)))

    js <- 0.5 * (kl_pm + kl_qm)
    return(js)
  }

  ## List to store summary results
  samp.res <- list()
  ## List to store cleaned signatures
  samp.cleaned <- list()

  ## Process each sample within file
  for(samp in names(res)) {
    message("Processing ", samp)
    ## Get posterior sampling
    fit <- res[[samp]]
    posterior <- rstan::extract(fit$fit)

    ## Extract background and exposure activity
    all_theta <- as.data.frame(posterior$norm_theta_b) %>% ## background activity
      mutate(norm_theta_t = posterior$norm_theta_t) %>% ## treatment activity
      sweep(x = ., MARGIN = 1, STATS = rowSums(.), FUN = "/") %>% ## Row normalize
      colMeans() ## Compute posterior mean

    ## Extract normalized posterior mean for exposure and background activity
    theta_t <- all_theta[length(all_theta)]
    theta_b <- all_theta[-length(all_theta)]

    ## Extract posterior exposure profile and select lower bound (2.5% credible interval)
    s_t <- apply(posterior$s_t, 2, quantile, probs = 0.025)
    s_t <- s_t / sum(s_t) ## normalize

    ## Convert relative probability distribution to count
    ## (Profile * activity) * total mutation count
    reconstruct_s_t <- (s_t * theta_t) * sum(fit$s_t)

    ## Do same for background profile
    reconstruct_s_b <- sapply(1:length(theta_b), function(x) {
      (as.numeric(fit$s_b[,x]) * theta_b[x]) * sum(fit$s_t)
    })

    ## If more than 1 background supplied, rowSum to get total mutation by mutation context
    if(length(reconstruct_s_b)>1) {
      reconstruct_s_b <- rowSums(reconstruct_s_b)
    }

    ## Sum count for exposure and background to get reconstructed
    reconstructed <- reconstruct_s_t + reconstruct_s_b

    ## If more than 1 background supplied, sum background activity
    if(length(theta_b) > 1) {
      theta_b <- sum(theta_b)
    }

    ## Reconstruction Evaluation ##
    p.dev_recon <- poisson_deviance(fit$s_t, reconstructed)/length(fit$s_t) ## Poisson Deviance
    js_recon <- js_divergence(fit$s_t/sum(fit$s_t), reconstructed/sum(reconstructed)) ## Jensen Shannon Divergence
    cs_recon <- lsa::cosine(fit$s_t, reconstructed)[[1]] ## Cosine Similarity

    ## Store summary in samp.res
    samp.res[[samp]] <- data.frame(sample = samp,
                                   original = sum(fit$s_t),
                                   reconstructed = sum(reconstructed),
                                   poisson_dev = p.dev_recon,
                                   js_recon = js_recon,
                                   cs_recon = cs_recon,
                                   theta_t = theta_t,
                                   theta_b = theta_b)

    ## Store cleaned profiles in samp.cleaned
    samp.cleaned[[samp]] <- data.frame(cleaned = reconstruct_s_t) %>% 'colnames<-' (samp)
  }
  ## Convert list to data frame
  samp.res <- as.data.frame(do.call(rbind, samp.res)) %>% remove_rownames()
  samp.cleaned <- as.data.frame(do.call(cbind, samp.cleaned)) %>%
    'rownames<-' (fit$MutationType) %>%
    rownames_to_column(var = "MutationType")

  ## Assign them to global environment
  assign("samp.cleaned", samp.cleaned, envir = .GlobalEnv)
  assign("samp.res", samp.res, envir = .GlobalEnv)
}

#' Plot SBS results.
#'
#' This function is designed to generate a visualization of the results from `SigRescueR()`
#' after data extraction (`SigRescueRExtract()`) using `samp.cleaned`, where the x-axis
#' represents the mutation context faceted by mutation type and y-axis represents percentage
#' of SBS mutation.
#'
#' @param clean Data frame representing the mutational catalogue. Each column corresponds
#' to a sample and must include a `MutationType` column (first column) specifying the
#' mutation context (e.g. `A[C>A]A`).
#' @param output_path Character string specifying the full path where the ouput `.pdf` file
#' will be saved. Default = ".".
#' @param filename Character string specifying the file name. Default = "clean_res".
#' @param dpi Numeric value indicating the resolution (dots per inch) for the saved plot.
#' Default = 600.
#'
#' @import ggplot2
#' @import dplyr
#' @import tibble
#' @import ggh4x
#' @import gridExtra
#' @importFrom magrittr %>%
#' @export

SigRescuePlot <- function(clean, output_path = ".", filename = "clean_res", dpi = 600) {
  plotlist <- list()
  ## Functions
  getSBSorder <- function() {
    counter <- 1
    df <- as.data.frame(matrix(data = NA, nrow = 96, ncol = 3))
    all_bp <- c("A", "C", "G", "T")
    pyr_muts <- c("C>A", "C>G", "C>T", "T>A", "T>C", "T>G")
    for(m in pyr_muts){
      for(a in all_bp){
        for(b in all_bp){
          df[counter,1] <- paste(a, "[",m, "]", b, sep="")
          df[counter,2] <- m
          df[counter,3] <- paste(a, substring(m,1,1),b, sep="")
          counter <- counter + 1 ## Add counter for next row
        }
      }
    }
    return(df)
  }

  sbs.df <- getSBSorder()

  ## Mutation context colors
  mut.color <- c('deepskyblue','black','red','lightgrey','yellowgreen','pink')

  ## Plot function 1
  plotSBS <- function(df, x.label, alpha = 1) {
    df.pd <- df %>% left_join(x = ., y = sbs.df, by = c("MutationType"="V1"))
    df.pd$MutationType <- factor(x = df.pd$MutationType, levels = sbs.df$V1)

    anno <- df.pd %>% dplyr::filter(V2 == "T>G") %>%
      mutate(x = Inf,
             y = Inf,
             label = paste0("Total: ", round(sum(df.pd$value), digits = 0))
      )

    p1 <- ggplot(data = df.pd, aes(x = MutationType, y = value/sum(value)*100)) +
      geom_col(aes(fill = V2), alpha = alpha) +
      theme_bw() +
      guides(fill = "none") +
      scale_fill_manual(values = mut.color) +
      facet_wrap2(.~V2, nrow = 1, scale = "free_x", drop = TRUE,
                  strip = strip_themed(
                    background_x = list(
                      element_rect(fill = mut.color[1], color = "transparent"),
                      element_rect(fill = mut.color[2], color = "transparent"),
                      element_rect(fill = mut.color[3], color = "transparent"),
                      element_rect(fill = mut.color[4], color = "transparent"),
                      element_rect(fill = mut.color[5], color = "transparent"),
                      element_rect(fill = mut.color[6], color = "transparent")
                    ),
                    text_x = list(
                      element_text(color = "white", face = "bold", family = "Arial", size = 6, margin = margin(1, 1, 1, 1))
                    )
                  )
      ) +
      geom_text(
        data = anno,
        aes(x = x, y = y, label = label),
        inherit.aes = FALSE,
        size = 2.7,
        vjust = 1.1,
        hjust = 1.1,
        family = "Arial",
        fontface = "plain"
      ) +
      scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
      scale_x_discrete(labels = setNames(sbs.df$V3, sbs.df$V1)) +
      coord_cartesian(clip = "off") +
      ylab("% SBS") + xlab(x.label) +
      theme(panel.border = element_blank(),
            strip.background = element_blank(),
            panel.spacing = unit(0, "lines"),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            axis.text.x = element_text(family = "Arial", angle = 90, vjust = 0.5, hjust = 1, size = 3),#, margin = margin(t = -1)),
            axis.ticks.x = element_blank(),
            axis.text.y = element_text(family = "Arial", size = 6),
            axis.title.y = element_text(family = "Arial", size = 8),
            axis.title.x = element_text(family = "Arial", size = 8))

    return(p1)
  }

  for(n in 2:ncol(clean)) {
    samp.name <- names(clean)[n]
    pd <- clean %>% .[,c(1,n)] %>% 'colnames<-' (c("MutationType", "value"))
    plotlist[[samp.name]] <- plotSBS(pd, x.label = samp.name)
  }

  arranged_plots_multiple_pages <- marrangeGrob(plotlist, nrow = 1, ncol = 1, top = NULL)
  ggsave(paste0(output_path, filename,".pdf"),
         plot = arranged_plots_multiple_pages,
         device = cairo_pdf,
         width = 6, height = 1.5,
         dpi = dpi,
         family = "Arial")
  dev.off()
}
